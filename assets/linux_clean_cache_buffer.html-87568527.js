import{_ as l,D as t,V as i,W as o,a0 as e,Y as n,Z as s,$ as p}from"./framework-7c77a285.js";const c={},d={href:"http://clearcache.sh",target:"_blank",rel:"noopener noreferrer"},u={href:"http://clearcache.sh",target:"_blank",rel:"noopener noreferrer"},h={href:"https://www.tecmint.com/11-cron-scheduling-task-examples-in-linux/",target:"_blank",rel:"noopener noreferrer"};function m(b,a){const r=t("ExternalLinkIcon");return i(),o("div",null,[a[9]||(a[9]=e(`<p>像任何其他的操作系统一样，GNU/Linux 已经实现的内存管理不仅有效，而且更好。但是，如果有任何进程正在蚕食你的内存，而你想要清除它的话，Linux 提供了一个刷新或清除 RAM 缓存方法。</p><h1 id="如何在-linux-中清除缓存-cache" tabindex="-1"><a class="header-anchor" href="#如何在-linux-中清除缓存-cache" aria-hidden="true">#</a> 如何在 Linux 中清除缓存（Cache）</h1><p>每个 Linux 系统有三种选项来清除缓存而不需要中断任何进程或服务。</p><p>（LCTT 译注：Cache，译作“缓存”，指 CPU 和内存之间高速缓存。Buffer，译作“缓冲区”，指在写入磁盘前的存储再内存中的内容。在本文中，Buffer 和 Cache 有时候会通指。）</p><ol><li>仅清除页面缓存（PageCache）</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sync</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token number">1</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="2"><li>清除目录项和 inode</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sync</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token number">2</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ol start="3"><li>清除页面缓存，目录项和 inode</li></ol><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sync</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>上述命令的说明：</p><p>sync 将刷新文件系统缓冲区（buffer），命令通过“;”分隔，顺序执行，shell 在执行序列中的下一个命令之前会等待命令的终止。正如内核文档中提到的，写入到 drop_cache 将清空缓存而不会杀死任何应用程序/服务，echo 命令做写入文件的工作。</p><p>如果你必须清除磁盘高速缓存，第一个命令在企业和生产环境中是最安全，&quot;...echo 1&gt; ...&quot;只会清除页面缓存。 在生产环境中不建议使用上面的第三个选项&quot;...echo 3 &gt; ...&quot; ，除非你明确自己在做什么，因为它会清除缓存页，目录项和 inodes。</p><h1 id="在-linux-上释放也许被内核所使用的缓冲区-buffer-和缓存-cache-是否是个好主意" tabindex="-1"><a class="header-anchor" href="#在-linux-上释放也许被内核所使用的缓冲区-buffer-和缓存-cache-是否是个好主意" aria-hidden="true">#</a> 在 Linux 上释放也许被内核所使用的缓冲区（Buffer）和缓存（Cache）是否是个好主意？</h1><p>当你设置许多设定想要检查效果时，如果它实际上是专门针对 I/O 范围的基准测试，那么你可能需要清除缓冲区和缓存。你可以如上所示删除缓存，无需重新启动系统（即无需停机）。</p><p>Linux 被设计成它在寻找磁盘之前到磁盘缓存寻找的方式。如果它发现该资源在缓存中，则该请求不会发送到磁盘。如果我们清理缓存，磁盘缓存就起不到作用了，系统会到磁盘上寻找资源。</p><p>此外，当清除缓存后它也将减慢系统运行速度，系统会将每一个被请求的资源再次加载到磁盘缓存中。</p>`,17)),n("p",null,[a[1]||(a[1]=s("现在，我们将创建一个 shell 脚本，通过一个 cron 调度任务在每天下午 2 点自动清除 RAM 缓存。如下创建一个 shell 脚本 ")),n("a",d,[a[0]||(a[0]=s("clearcache.sh")),p(r)]),a[2]||(a[2]=s(" 并在其中添加以下行："))]),a[10]||(a[10]=e(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token shebang important">#!/bin/bash</span>
<span class="token comment"># 注意，我们这里使用了 &quot;echo 3&quot;，但是不推荐使用在产品环境中，应该使用 &quot;echo 1&quot;</span>
<span class="token builtin class-name">echo</span> <span class="token string">&quot;echo 3 &gt; /proc/sys/vm/drop_caches&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,1)),n("p",null,[a[4]||(a[4]=s("给 ")),n("a",u,[a[3]||(a[3]=s("clearcache.sh")),p(r)]),a[5]||(a[5]=s(" 文件设置执行权限"))]),a[11]||(a[11]=e(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">chmod</span> <span class="token number">755</span> clearcache.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在，当你需要清除内存缓存时只需要调用脚本。</p><p>现在设置一个每天下午 2 点的定时任务来清除 RAM 缓存，打开 crontab 进行编辑。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">crontab</span> <span class="token parameter variable">-e</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h1><p>添加以下行，保存并退出。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>0 3 * * * /path/to/clearcache.sh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,7)),n("p",null,[a[7]||(a[7]=s("有关如何创建一个定时任务，更多细节你可以查看我们的文章 ")),n("a",h,[a[6]||(a[6]=s("11 个定时调度任务的例子")),p(r)]),a[8]||(a[8]=s("。"))]),a[12]||(a[12]=e(`<h1 id="在生产环境的服务器上自动清除-ram-是否是一个好主意" tabindex="-1"><a class="header-anchor" href="#在生产环境的服务器上自动清除-ram-是否是一个好主意" aria-hidden="true">#</a> 在生产环境的服务器上自动清除 RAM 是否是一个好主意？</h1><p>不！它不是。想想一个情况，当你已经预定脚本在每天下午 2 点来清除内存缓存。那么其时该脚本会执行并刷新你的内存缓存。在某一天由于某些原因，可能您的网站的在线用户会超过预期地从你的服务器请求资源。</p><p>而在这时，按计划调度的脚本运行了，并清除了缓存中的一切。当所有的用户都从磁盘读取数据时，这将导致服务器崩溃并损坏数据库。因此，清除缓存仅在必要时并且在你的预料之中，否则你就是个呆瓜系统管理员</p><h1 id="如何清除-linux-的交换空间" tabindex="-1"><a class="header-anchor" href="#如何清除-linux-的交换空间" aria-hidden="true">#</a> 如何清除 Linux 的交换空间？</h1><p>如果你想清除掉的空间，你可以运行下面的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>swapoff <span class="token parameter variable">-a</span> <span class="token operator">&amp;&amp;</span> <span class="token function">swapon</span> <span class="token parameter variable">-a</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>此外，了解有关风险后，您可以将上面的命令添加到 cron 中。</p><p>现在，我们将上面两种命令结合成一个命令，写成正确的脚本来同时清除 RAM 缓存和交换空间。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">echo</span> <span class="token number">3</span> <span class="token operator">&gt;</span> /proc/sys/vm/drop_caches <span class="token operator">&amp;&amp;</span> swapoff <span class="token parameter variable">-a</span> <span class="token operator">&amp;&amp;</span> <span class="token function">swapon</span> <span class="token parameter variable">-a</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">printf</span> <span class="token string">&#39;\\n%s\\n&#39;</span> <span class="token string">&#39;Ram-cache and Swap Cleared&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">su</span> <span class="token parameter variable">-c</span> <span class="token string">&#39;echo 3 &gt; /proc/sys/vm/drop_caches&#39;</span> <span class="token operator">&amp;&amp;</span> swapoff <span class="token parameter variable">-a</span> <span class="token operator">&amp;&amp;</span> <span class="token function">swapon</span> <span class="token parameter variable">-a</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">printf</span> <span class="token string">&#39;\\n%s\\n&#39;</span> <span class="token string">&#39;Ram-cache and Swap Cleared&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在测试上面的命令之前，我们在执行脚本前后运行“free -m” 来检查缓存。</p>`,12))])}const g=l(c,[["render",m],["__file","linux_clean_cache_buffer.html.vue"]]);export{g as default};
