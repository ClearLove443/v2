import{_ as a,V as r,W as n,a0 as i}from"./framework-e0f7ab62.js";const t={};function o(d,e){return r(),n("div",null,[...e[0]||(e[0]=[i(`<h2 id="一-springboot-spring" tabindex="-1"><a class="header-anchor" href="#一-springboot-spring" aria-hidden="true">#</a> 一.SpringBoot/spring</h2><h3 id="springbootapplication" tabindex="-1"><a class="header-anchor" href="#springbootapplication" aria-hidden="true">#</a> @SpringBootApplication:</h3><p>包含@Configuration、@EnableAutoConfiguration、@ComponentScan 通常用在主类上；</p><h3 id="repository" tabindex="-1"><a class="header-anchor" href="#repository" aria-hidden="true">#</a> @Repository:</h3><p>用于标注数据访问组件，即 DAO 组件；</p><h3 id="service" tabindex="-1"><a class="header-anchor" href="#service" aria-hidden="true">#</a> @Service:</h3><p>用于标注业务层组件；</p><h3 id="restcontroller" tabindex="-1"><a class="header-anchor" href="#restcontroller" aria-hidden="true">#</a> @RestController:</h3><p>用于标注控制层组件(如 struts 中的 action)，包含@Controller 和@ResponseBody；</p><h3 id="controller" tabindex="-1"><a class="header-anchor" href="#controller" aria-hidden="true">#</a> @Controller:</h3><p>用于标注是控制层组件，需要返回页面时请用@Controller 而不是@RestController；</p><h3 id="component" tabindex="-1"><a class="header-anchor" href="#component" aria-hidden="true">#</a> @Component:</h3><p>泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注；</p><h3 id="responsebody" tabindex="-1"><a class="header-anchor" href="#responsebody" aria-hidden="true">#</a> @ResponseBody:</h3><p>表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用，在使用@RequestMapping 后，返回值通常解析为跳转路径， 加上@responsebody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中；比如异步获取 json 数据，加上@responsebody 后，会直接返回 json 数据；</p><h3 id="requestbody" tabindex="-1"><a class="header-anchor" href="#requestbody" aria-hidden="true">#</a> @RequestBody:</h3><p>参数前加上这个注解之后，认为该参数必填。表示接受 json 字符串转为对象 List 等；</p><h3 id="componentscan" tabindex="-1"><a class="header-anchor" href="#componentscan" aria-hidden="true">#</a> @ComponentScan:</h3><p>组件扫描。个人理解相当于，如果扫描到有@Component @Controller @Service 等这些注解的类，则把这些类注册为 bean</p><h3 id="configuration" tabindex="-1"><a class="header-anchor" href="#configuration" aria-hidden="true">#</a> @Configuration:</h3><p>指出该类是 Bean 配置的信息源，相当于 XML 中的，一般加在主类上；</p><h3 id="import" tabindex="-1"><a class="header-anchor" href="#import" aria-hidden="true">#</a> @Import：</h3><p>用来导入其他配置类。</p><h3 id="importresource" tabindex="-1"><a class="header-anchor" href="#importresource" aria-hidden="true">#</a> @ImportResource：</h3><p>用来加载 xml 配置文件。</p><h3 id="bean" tabindex="-1"><a class="header-anchor" href="#bean" aria-hidden="true">#</a> @Bean:</h3><p>相当于 XML 中的,放在方法的上面，而不是类，意思是产生一个 bean,并交给 spring 管理；</p><h3 id="value" tabindex="-1"><a class="header-anchor" href="#value" aria-hidden="true">#</a> @Value：</h3><p>注入 Spring boot application.properties 配置的属性的值。</p><h3 id="inject" tabindex="-1"><a class="header-anchor" href="#inject" aria-hidden="true">#</a> @Inject：</h3><p>等价于默认的@Autowired，只是没有 required 属性</p><h3 id="enableautoconfiguration" tabindex="-1"><a class="header-anchor" href="#enableautoconfiguration" aria-hidden="true">#</a> @EnableAutoConfiguration:</h3><p>让 Spring Boot 根据应用所声明的依赖来对 Spring 框架进行自动配置，一般加在主类上；</p><h3 id="autowired" tabindex="-1"><a class="header-anchor" href="#autowired" aria-hidden="true">#</a> @AutoWired:</h3><p>byType 方式。把配置好的 Bean 拿来用，完成属性、方法的组装，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作； 当加上（required=false）时，就算找不到 bean 也不报错；</p><h3 id="qualifier" tabindex="-1"><a class="header-anchor" href="#qualifier" aria-hidden="true">#</a> @Qualifier:</h3><p>当有多个同一类型的 Bean 时，可以用@Qualifier(&quot;name&quot;)来指定。与@Autowired 配合使用；</p><h3 id="resource-name-name-type-type" tabindex="-1"><a class="header-anchor" href="#resource-name-name-type-type" aria-hidden="true">#</a> @Resource(name=&quot;name&quot;,type=&quot;type&quot;)：</h3><p>没有括号内内容的话，默认 byName。与@Autowired 干类似的事；</p><h3 id="requestmapping" tabindex="-1"><a class="header-anchor" href="#requestmapping" aria-hidden="true">#</a> @RequestMapping:</h3><p>RequestMapping 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径；</p><pre><code>该注解有六个属性:
params:指定request中必须包含某些参数值是，才让该方法处理。
headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。
value:指定请求的实际地址，指定的地址可以是URI Template 模式
method:指定请求的method类型， GET、POST、PUT、DELETE等
consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html;
produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回。
</code></pre><h3 id="getmapping、-postmapping-等" tabindex="-1"><a class="header-anchor" href="#getmapping、-postmapping-等" aria-hidden="true">#</a> @GetMapping、@PostMapping 等:</h3><p>相当于@RequestMapping（value=&quot;/&quot;，method=RequestMethod.GetPostPutDelete 等） 。是个组合注解；</p><h3 id="requestparam" tabindex="-1"><a class="header-anchor" href="#requestparam" aria-hidden="true">#</a> @RequestParam:</h3><p>用在方法的参数前面。相当于 request.getParameter；</p><h3 id="pathvariable" tabindex="-1"><a class="header-anchor" href="#pathvariable" aria-hidden="true">#</a> @PathVariable:</h3><p>路径变量。如 RequestMapping(&quot;user/get/mac/{macAddress}&quot;) ；</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getByMacAddress</span><span class="token punctuation">(</span>
<span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">&quot;macAddress&quot;</span><span class="token punctuation">)</span> <span class="token class-name">String</span> macAddress<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//do something;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>参数与大括号里的名字相同的话，注解后括号里的内容可以不填。</p><h3 id="jsonbackreference" tabindex="-1"><a class="header-anchor" href="#jsonbackreference" aria-hidden="true">#</a> @JsonBackReference</h3><p>解决嵌套外链问题</p><h3 id="repositoryrestresourcepublic" tabindex="-1"><a class="header-anchor" href="#repositoryrestresourcepublic" aria-hidden="true">#</a> @RepositoryRestResourcepublic</h3><p>配合 spring-boot-starter-data-rest 使用</p><h2 id="二-jpa" tabindex="-1"><a class="header-anchor" href="#二-jpa" aria-hidden="true">#</a> 二.Jpa</h2><h3 id="entity" tabindex="-1"><a class="header-anchor" href="#entity" aria-hidden="true">#</a> @Entity:</h3><h3 id="table-name" tabindex="-1"><a class="header-anchor" href="#table-name" aria-hidden="true">#</a> @Table(name=&quot;&quot;):</h3><p>表明这是一个实体类。一般用于 jpa ，这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table 可以省略；</p><h3 id="mappedsuperclass" tabindex="-1"><a class="header-anchor" href="#mappedsuperclass" aria-hidden="true">#</a> @MappedSuperClass:</h3><p>用在确定是父类的 entity 上。父类的属性子类可以继承；</p><h3 id="norepositorybean" tabindex="-1"><a class="header-anchor" href="#norepositorybean" aria-hidden="true">#</a> @NoRepositoryBean:</h3><p>一般用作父类的 repository，有这个注解，spring 不会去实例化该 repository；</p><h3 id="column" tabindex="-1"><a class="header-anchor" href="#column" aria-hidden="true">#</a> @Column:</h3><p>如果字段名与列名相同，则可以省略；</p><h3 id="id" tabindex="-1"><a class="header-anchor" href="#id" aria-hidden="true">#</a> @Id:</h3><p>表示该属性为主键；</p><h3 id="generatedvalue-strategy-generationtype-sequence-generator-repair-seq" tabindex="-1"><a class="header-anchor" href="#generatedvalue-strategy-generationtype-sequence-generator-repair-seq" aria-hidden="true">#</a> @GeneratedValue(strategy=GenerationType.SEQUENCE,generator = &quot;repair_seq&quot;):</h3><p>表示主键生成策略是 sequence（可以为 Auto、IDENTITY、native 等，Auto 表示可在多个数据库间切换），指定 sequence 的名字是 repair_seq；</p><h3 id="sequencegeneretor-name-repair-seq-sequencename-seq-repair-allocationsize-1" tabindex="-1"><a class="header-anchor" href="#sequencegeneretor-name-repair-seq-sequencename-seq-repair-allocationsize-1" aria-hidden="true">#</a> @SequenceGeneretor(name = &quot;repair_seq&quot;, sequenceName = &quot;seq_repair&quot;, allocationSize = 1):</h3><p>name 为 sequence 的名称，以便使用，sequenceName 为数据库的 sequence 名称，两个名称可以一致；</p><h3 id="transient" tabindex="-1"><a class="header-anchor" href="#transient" aria-hidden="true">#</a> @Transient:</h3><p>表示该属性并非一个到数据库表的字段的映射,ORM 框架将忽略该属性. 如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM 框架默认其注解为@Basic；</p><h3 id="basic-fetch-fetchtype-lazy" tabindex="-1"><a class="header-anchor" href="#basic-fetch-fetchtype-lazy" aria-hidden="true">#</a> @Basic(fetch=FetchType.LAZY):</h3><p>标记可以指定实体属性的加载方式；</p><h3 id="jsonignore" tabindex="-1"><a class="header-anchor" href="#jsonignore" aria-hidden="true">#</a> @JsonIgnore:</h3><p>作用是 json 序列化时将 java bean 中的一些属性忽略掉,序列化和反序列化都受影响；</p><h3 id="joincolumn-name-loginid" tabindex="-1"><a class="header-anchor" href="#joincolumn-name-loginid" aria-hidden="true">#</a> @JoinColumn(name=&quot;loginId&quot;):</h3><p>一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</p><h3 id="onetoone" tabindex="-1"><a class="header-anchor" href="#onetoone" aria-hidden="true">#</a> @OneToOne</h3><p>对应 Hibernate 配置文件中的一对一</p><h3 id="onetomany" tabindex="-1"><a class="header-anchor" href="#onetomany" aria-hidden="true">#</a> @OneToMany</h3><p>对应 Hibernate 配置文件中的一对多</p><h3 id="manytoone" tabindex="-1"><a class="header-anchor" href="#manytoone" aria-hidden="true">#</a> @ManyToOne:</h3><p>对应 Hibernate 配置文件中的多对一</p><h2 id="三-全局异常处理" tabindex="-1"><a class="header-anchor" href="#三-全局异常处理" aria-hidden="true">#</a> 三.全局异常处理</h2><h3 id="controlleradvice" tabindex="-1"><a class="header-anchor" href="#controlleradvice" aria-hidden="true">#</a> @ControllerAdvice:</h3><p>包含@Component。可以被扫描到。统一处理异常；</p><h3 id="exceptionhandler-exception-class" tabindex="-1"><a class="header-anchor" href="#exceptionhandler-exception-class" aria-hidden="true">#</a> @ExceptionHandler(Exception.class):</h3><p>用在方法上面表示遇到这个异常就执行以下方法。</p><h2 id="四-springcloud" tabindex="-1"><a class="header-anchor" href="#四-springcloud" aria-hidden="true">#</a> 四.springcloud</h2><h3 id="enableeurekaserver" tabindex="-1"><a class="header-anchor" href="#enableeurekaserver" aria-hidden="true">#</a> @EnableEurekaServer:</h3><p>用在 springboot 启动类上，表示这是一个 eureka 服务注册中心；</p><h3 id="enablediscoveryclient" tabindex="-1"><a class="header-anchor" href="#enablediscoveryclient" aria-hidden="true">#</a> @EnableDiscoveryClient:</h3><p>用在 springboot 启动类上，表示这是一个服务，可以被注册中心找到；</p><h3 id="loadbalanced" tabindex="-1"><a class="header-anchor" href="#loadbalanced" aria-hidden="true">#</a> @LoadBalanced:</h3><p>开启负载均衡能力；</p><h3 id="enablecircuitbreaker" tabindex="-1"><a class="header-anchor" href="#enablecircuitbreaker" aria-hidden="true">#</a> @EnableCircuitBreaker:</h3><p>用在启动类上，开启断路器功能；</p><h3 id="hystrixcommand-fallbackmethod-backmethod" tabindex="-1"><a class="header-anchor" href="#hystrixcommand-fallbackmethod-backmethod" aria-hidden="true">#</a> @HystrixCommand(fallbackMethod=&quot;backMethod&quot;):</h3><p>用在方法上，fallbackMethod 指定断路回调方法；</p><h3 id="enableconfigserver" tabindex="-1"><a class="header-anchor" href="#enableconfigserver" aria-hidden="true">#</a> @EnableConfigServer:</h3><p>用在启动类上，表示这是一个配置中心，开启 Config Server；</p><h3 id="enablezuulproxy" tabindex="-1"><a class="header-anchor" href="#enablezuulproxy" aria-hidden="true">#</a> @EnableZuulProxy:</h3><p>开启 zuul 路由，用在启动类上；</p><h3 id="springcloudapplication" tabindex="-1"><a class="header-anchor" href="#springcloudapplication" aria-hidden="true">#</a> @SpringCloudApplication:</h3><p>包含</p><ul><li>@SpringBootApplication</li><li>@EnableDiscovertyClient</li><li>@EnableCircuitBreaker</li></ul><p>分别是 SpringBoot 注解、注册服务中心 Eureka 注解、断路器注解。对于 SpringCloud 来说，这是每一微服务必须应有的三个注解，所以才推出了@SpringCloudApplication 这一注解集合。</p>`,108)])])}const h=a(t,[["render",o],["__file","springboot_annotation.html.vue"]]);export{h as default};
